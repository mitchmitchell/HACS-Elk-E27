{"run_id": "0c91bd7f107f4f7c93fc2d715719232b", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-30T03:38:05Z", "meta": {"pid": 38077}}
{"run_id": "0c91bd7f107f4f7c93fc2d715719232b", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_end", "t_ms": 86356, "ts_utc": "2025-12-30T03:39:31Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.session.Session object at 0x107b1bb60>\n\n    def _recv_some(self, *, max_bytes: int) -> bytes:\n        \"\"\"\n        Read from socket; may raise TimeoutError or ConnectionError.\n        Kept as a method so tests can monkeypatch it.\n        \"\"\"\n        self._require_ready()\n        assert self.sock is not None\n    \n        try:\n>           data = self.sock.recv(max_bytes)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^\nE           ConnectionResetError: [Errno 54] Connection reset by peer\n\nelke27_lib/session.py:239: ConnectionResetError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_configured_names() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"60.0\") or 60.0)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\"elke27_lib.features.control\", \"elke27_lib.features.area\", \"elke27_lib.features.zone\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n        link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n        session_cfg = SessionConfig(host=host, port=port, hello_timeout_s=timeout_s)\n        await elk.connect(link_keys, client_identity=client_identity, session_config=session_cfg)\n    \n        pin_value = _env(\"ELKE27_PIN\")\n        if pin_value:\n            pin = int(pin_value)\n            auth_msg = {\"seq\": 110, \"authenticate\": {\"pin\": pin}}\n            elk.session.send_json(auth_msg)\n            print(\"Authenticate sent\")\n    \n        elk.request((\"control\", \"get_version_info\"))\n        elk.request((\"area\", \"get_configured\"))\n        elk.request((\"zone\", \"get_configured\"))\n    \n        area_auth_required = False\n        zone_auth_required = False\n        area_names_seen = False\n        zone_names_seen = False\n        area_api_errors: list[int] = []\n        zone_api_errors: list[int] = []\n    \n        deadline = time.monotonic() + timeout_s\n        next_version_retry = time.monotonic() + 5.0\n        while time.monotonic() < deadline:\n>           elk.session.pump_once(timeout_s=0.5)\n\ntest/test_e27_configured_names_live.py:91: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nelke27_lib/session.py:404: in pump_once\n    obj = self.recv_json(timeout_s=timeout_s)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nelke27_lib/session.py:359: in recv_json\n    frame_no_crc = self._recv_one_frame_no_crc(timeout_s=timeout_s)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nelke27_lib/session.py:287: in _recv_one_frame_no_crc\n    chunk = self._recv_some(max_bytes=self.cfg.recv_max_bytes)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.session.Session object at 0x107b1bb60>\n\n    def _recv_some(self, *, max_bytes: int) -> bytes:\n        \"\"\"\n        Read from socket; may raise TimeoutError or ConnectionError.\n        Kept as a method so tests can monkeypatch it.\n        \"\"\"\n        self._require_ready()\n        assert self.sock is not None\n    \n        try:\n            data = self.sock.recv(max_bytes)\n        except socket.timeout as e:\n            raise TimeoutError(\"Timed out waiting for data from the panel.\") from e\n        except OSError as e:\n>           raise SessionIOError(\n                f\"Socket read failed from {self.cfg.host}:{self.cfg.port}: {e}\"\n            ) from e\nE           elke27_lib.session.SessionIOError: Socket read failed from 192.168.1.197:2101: [Errno 54] Connection reset by peer\n\nelke27_lib/session.py:243: SessionIOError"}}
