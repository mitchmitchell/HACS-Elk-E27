{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_area_get_status_live.py::test_live_area_get_status", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T08:33:04Z", "meta": {"pid": 94016}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_area_get_status_live.py::test_live_area_get_status", "record_type": "test_end", "t_ms": 27, "ts_utc": "2025-12-29T08:33:04Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x103924c20>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        import socket\n    \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:303: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_area_get_status() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"10.0\") or 10.0)\n        area_id = int(_env(\"ELKE27_AREA_ID\", \"1\") or 1)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n    \n        elk = Elk(features=[\"elke27_lib.features.area\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_area_get_status_live.py:61: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x103924c20>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except Exception as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:329: ElkError"}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_link_raw_buffers.py::test_link_raw_framed_and_deframed_buffers", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T08:33:04Z", "meta": {"pid": 94016}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_link_raw_buffers.py::test_link_raw_framed_and_deframed_buffers", "record_type": "test_end", "t_ms": 11, "ts_utc": "2025-12-29T08:33:04Z", "outcome": "fail", "error": {"when": "call", "longrepr": "@pytest.mark.integration\n    def test_link_raw_framed_and_deframed_buffers() -> None:\n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n    \n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"5.0\") or 5.0)\n    \n        client_identity = E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n    \n>       with socket.create_connection((host, port), timeout=timeout_s) as sock:\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_link_raw_buffers.py:51: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/socket.py:870: in create_connection\n    raise exceptions[0]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.197', 2101), timeout = 5.0, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None, *, all_errors=False):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default. When a connection\n        cannot be created, raises the last error if *all_errors* is False,\n        and an ExceptionGroup of all errors if *all_errors* is True.\n        \"\"\"\n    \n        host, port = address\n        exceptions = []\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               PermissionError: [Errno 1] Operation not permitted\n\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/socket.py:855: PermissionError"}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_network_param_live.py::test_live_network_param_getters", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T08:33:04Z", "meta": {"pid": 94016}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_network_param_live.py::test_live_network_param_getters", "record_type": "test_end", "t_ms": 15, "ts_utc": "2025-12-29T08:33:04Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x1039691d0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        import socket\n    \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:303: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_network_param_getters() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"10.0\") or 10.0)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\"elke27_lib.features.network_param\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_network_param_live.py:64: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x1039691d0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except Exception as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:329: ElkError"}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_output_tstat_live.py::test_live_output_and_tstat_status", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T08:33:04Z", "meta": {"pid": 94016}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_output_tstat_live.py::test_live_output_and_tstat_status", "record_type": "test_end", "t_ms": 16, "ts_utc": "2025-12-29T08:33:04Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x103968690>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        import socket\n    \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:303: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_output_and_tstat_status() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"10.0\") or 10.0)\n        output_id = int(_env(\"ELKE27_OUTPUT_ID\", \"1\") or 1)\n        tstat_id = int(_env(\"ELKE27_TSTAT_ID\", \"1\") or 1)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\"elke27_lib.features.output\", \"elke27_lib.features.tstat\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_output_tstat_live.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x103968690>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except Exception as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:329: ElkError"}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_table_info_live.py::test_live_table_info_calls", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T08:33:04Z", "meta": {"pid": 94016}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_table_info_live.py::test_live_table_info_calls", "record_type": "test_end", "t_ms": 15, "ts_utc": "2025-12-29T08:33:04Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x1039548a0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        import socket\n    \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:303: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_table_info_calls() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"10.0\") or 10.0)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\n            \"elke27_lib.features.area\",\n            \"elke27_lib.features.zone\",\n            \"elke27_lib.features.output\",\n            \"elke27_lib.features.tstat\",\n        ])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_table_info_live.py:70: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x1039548a0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except Exception as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:329: ElkError"}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_zone_defs_live.py::test_live_zone_defs_and_flags", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T08:33:04Z", "meta": {"pid": 94016}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_zone_defs_live.py::test_live_zone_defs_and_flags", "record_type": "test_end", "t_ms": 15, "ts_utc": "2025-12-29T08:33:04Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x1037e5810>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        import socket\n    \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:303: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_zone_defs_and_flags() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"10.0\") or 10.0)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\"elke27_lib.features.zone\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_zone_defs_live.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x1037e5810>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except Exception as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:329: ElkError"}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_zone_live.py::test_live_zone_get_configured_and_status", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T08:33:04Z", "meta": {"pid": 94016}}
{"run_id": "553ee25b64584203a740434a0e953c89", "test_id": "test/test_e27_zone_live.py::test_live_zone_get_configured_and_status", "record_type": "test_end", "t_ms": 15, "ts_utc": "2025-12-29T08:33:05Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x1037439b0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        import socket\n    \n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:303: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_zone_get_configured_and_status() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"10.0\") or 10.0)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\"elke27_lib.features.zone\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_zone_live.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x1037439b0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            import socket\n    \n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except Exception:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except Exception as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:329: ElkError"}}
