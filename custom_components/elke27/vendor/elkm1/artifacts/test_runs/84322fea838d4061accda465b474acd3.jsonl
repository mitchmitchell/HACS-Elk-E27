{"run_id": "84322fea838d4061accda465b474acd3", "test_id": "test/test_e27_area_info_live.py::test_live_area_info", "record_type": "test_start", "t_ms": 0, "ts_utc": "2026-01-01T04:26:48Z", "meta": {"pid": 191}}
{"run_id": "84322fea838d4061accda465b474acd3", "test_id": "test/test_e27_area_info_live.py::test_live_area_info", "record_type": "test_end", "t_ms": 37, "ts_utc": "2026-01-01T04:26:48Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x1079f86e0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except OSError:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:339: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_area_info() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"60.0\") or 60.0)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\"elke27_lib.features.area\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_area_info_live.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x1079f86e0>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except OSError:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except (E27Error, OSError, RuntimeError, ValueError) as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:365: ElkError"}}
{"run_id": "84322fea838d4061accda465b474acd3", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_start", "t_ms": 0, "ts_utc": "2026-01-01T04:26:48Z", "meta": {"pid": 191}}
{"run_id": "84322fea838d4061accda465b474acd3", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_end", "t_ms": 24, "ts_utc": "2026-01-01T04:26:48Z", "outcome": "fail", "error": {"when": "call", "longrepr": "self = <elke27_lib.elk.Elk object at 0x107743e00>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except OSError:\n                    pass\n    \n        try:\n>           link_keys = await asyncio.to_thread(_do_link_sync)\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nelke27_lib/elk.py:363: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def _do_link_sync() -> linking.E27LinkKeys:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        try:\n            sock.settimeout(float(timeout_s))\n>           sock.connect((host, port))\nE           PermissionError: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:339: PermissionError\n\nThe above exception was the direct cause of the following exception:\n\n    @pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_configured_names() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"60.0\") or 60.0)\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        elk = Elk(features=[\"elke27_lib.features.control\", \"elke27_lib.features.area\", \"elke27_lib.features.zone\"])\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n>       link_keys = await elk.link(panel, client_identity, creds, timeout_s=timeout_s)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_e27_configured_names_live.py:67: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.elk.Elk object at 0x107743e00>\npanel = {'host': '192.168.1.197', 'port': 2101}\nclient_identity = E27Identity(mn='0222', sn='001122334455', fwver='1.0', hwver='1.0', osver='1.0')\ncredentials = _Credentials(access_code='03261105', passphrase='LillyNicciMurdoch')\n\n    async def link(\n        self,\n        panel: discovery.ElkSystem | Dict[str, Any],\n        client_identity: linking.E27Identity,\n        credentials: Any,\n        *,\n        timeout_s: float = 10.0,\n    ) -> linking.E27LinkKeys:\n        \"\"\"\n        Elk.link accepts one element of the list returned by Elk.discover plus\n        linking.E27Identity (client_identity) and linking.E27Credentials (accesscode + passphrase)\n        and returns E27LinkKeys.\n    \n        This is provisioning-time API_LINK; it is explicitly outside Session responsibility.\n        \"\"\"\n        host, port = _panel_host_port(panel)\n    \n        if client_identity is None:\n            raise ElkError(\"link(): client_identity is required.\")\n        if credentials is None:\n            raise ElkError(\"link(): credentials are required.\")\n    \n        # We expect credentials.access_code and credentials.passphrase (per requirement).\n        access_code = getattr(credentials, \"access_code\", None) or getattr(credentials, \"accesscode\", None)\n        passphrase = getattr(credentials, \"passphrase\", None)\n    \n        if not isinstance(access_code, str) or not access_code:\n            raise ElkError(\"link(): credentials.access_code (string) is required.\")\n        if not isinstance(passphrase, str) or not passphrase:\n            raise ElkError(\"link(): credentials.passphrase (string) is required.\")\n    \n        def _do_link_sync() -> linking.E27LinkKeys:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            try:\n                sock.settimeout(float(timeout_s))\n                sock.connect((host, port))\n    \n                # Wait for discovery hello/nonce (cleartext)\n                nonce = linking.wait_for_discovery_nonce(sock, timeout_s=float(timeout_s))\n                nonce_bytes = nonce.encode(\"utf-8\")\n    \n                # Perform API_LINK. Existing library signature is sock-based; newer wrappers may differ.\n                return linking.perform_api_link(\n                    sock=sock,\n                    client_identity=client_identity,\n                    access_code=access_code,\n                    passphrase=passphrase,\n                    mn_for_hash=client_identity.mn,\n                    discovery_nonce=nonce_bytes,\n                    seq=110,\n                    timeout_s=float(timeout_s),\n                )\n            finally:\n                try:\n                    sock.close()\n                except OSError:\n                    pass\n    \n        try:\n            link_keys = await asyncio.to_thread(_do_link_sync)\n        except (E27Error, OSError, RuntimeError, ValueError) as e:\n>           raise ElkError(f\"Linking failed for {host}:{port}: {e}\") from e\nE           elke27_lib.elk.ElkError: Linking failed for 192.168.1.197:2101: [Errno 1] Operation not permitted\n\nelke27_lib/elk.py:365: ElkError"}}
