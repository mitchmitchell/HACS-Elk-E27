{"run_id": "63bc1b582d7f4761a4b2b89e374e06b8", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_start", "t_ms": 0, "ts_utc": "2026-01-04T04:07:20Z", "meta": {"pid": 44093}}
{"run_id": "63bc1b582d7f4761a4b2b89e374e06b8", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_end", "t_ms": 93909, "ts_utc": "2026-01-04T04:08:54Z", "outcome": "fail", "error": {"when": "call", "longrepr": "@pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_configured_names() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"60.0\") or 60.0)\n        max_runtime_s = float(_env(\"ELKE27_TEST_TIMEOUT_S\", str(timeout_s)) or timeout_s)\n        if max_runtime_s > 60.0:\n            max_runtime_s = 60.0\n        if max_runtime_s <= 0:\n            max_runtime_s = timeout_s\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        client = Elke27Client(\n            features=[\"elke27_lib.features.control\", \"elke27_lib.features.area\", \"elke27_lib.features.zone\"]\n        )\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n        link_result = await client.link(panel, client_identity, creds, timeout_s=timeout_s)\n        if not link_result.ok:\n            pytest.fail(f\"Link failed: {link_result.error}\")\n        link_keys = link_result.data\n        session_cfg = SessionConfig(host=host, port=port, hello_timeout_s=timeout_s)\n        connect_result = await client.connect(link_keys, client_identity=client_identity, session_config=session_cfg)\n        if not connect_result.ok:\n            pytest.fail(f\"Connect failed: {connect_result.error}\")\n    \n        pin_value = _env(\"ELKE27_PIN\")\n        if pin_value:\n            pin = int(pin_value)\n            auth_msg = {\"seq\": 110, \"authenticate\": {\"pin\": pin}}\n            client._kernel.session.send_json(auth_msg)\n            print(\"Authenticate sent\")\n    \n        def _send_requests() -> None:\n            client.request((\"control\", \"get_version_info\"))\n            client.request((\"area\", \"get_configured\"))\n            client.request((\"zone\", \"get_configured\"))\n    \n        _send_requests()\n    \n        area_auth_required = False\n        zone_auth_required = False\n        area_names_seen = False\n        zone_names_seen = False\n        area_api_errors: list[int] = []\n        zone_api_errors: list[int] = []\n    \n        start = time.monotonic()\n        next_debug = start + 5.0\n        total_deadline = time.monotonic() + max_runtime_s\n        next_version_retry = time.monotonic() + 5.0\n        while time.monotonic() < total_deadline:\n            try:\n                await asyncio.to_thread(client._kernel.session.pump_once, timeout_s=0.5)\n            except (SessionIOError, SessionProtocolError):\n                await client._kernel.reconnect()\n                if pin_value:\n                    auth_msg = {\"seq\": 110, \"authenticate\": {\"pin\": int(pin_value)}}\n                    client._kernel.session.send_json(auth_msg)\n                    print(\"Authenticate sent\")\n                _send_requests()\n                area_auth_required = False\n                zone_auth_required = False\n                area_names_seen = False\n                zone_names_seen = False\n                area_api_errors.clear()\n                zone_api_errors.clear()\n                next_version_retry = time.monotonic() + 5.0\n                continue\n            for evt in client.drain_events():\n                if evt.kind == AuthorizationRequiredEvent.KIND:\n                    if evt.scope == \"area\":\n                        area_auth_required = True\n                    if evt.scope == \"zone\":\n                        zone_auth_required = True\n                if evt.kind == ApiError.KIND:\n                    if evt.scope == \"area\":\n                        if isinstance(evt.error_code, int):\n                            area_api_errors.append(evt.error_code)\n                    if evt.scope == \"zone\":\n                        if isinstance(evt.error_code, int):\n                            zone_api_errors.append(evt.error_code)\n                if evt.kind == AreaAttribsUpdated.KIND:\n                    area_names_seen = True\n                if evt.kind == ZoneAttribsUpdated.KIND:\n                    zone_names_seen = True\n    \n            inv = client.state.inventory\n            panel_info = client.state.panel\n            now = time.monotonic()\n            if (not panel_info.model or not panel_info.firmware or not panel_info.serial) and now >= next_version_retry:\n                client.request((\"control\", \"get_version_info\"))\n                next_version_retry = time.monotonic() + 5.0\n            panel_ready = bool(panel_info.model) and bool(panel_info.firmware) and bool(panel_info.serial)\n            if inv.configured_areas_complete and inv.configured_zones_complete:\n                if (inv.configured_areas and area_names_seen) or area_auth_required:\n                    if (inv.configured_zones and zone_names_seen) or zone_auth_required:\n                        if panel_ready:\n                            break\n            if now >= next_debug:\n                elapsed = now - start\n                print(\n                    \"debug loop: \"\n                    f\"elapsed={elapsed:.1f}s \"\n                    f\"panel_ready={panel_ready} \"\n                    f\"areas_complete={inv.configured_areas_complete} \"\n                    f\"zones_complete={inv.configured_zones_complete} \"\n                    f\"area_names_seen={area_names_seen} \"\n                    f\"zone_names_seen={zone_names_seen}\"\n                )\n                next_debug = now + 5.0\n    \n        panel_info = client.state.panel\n        print(f\"panel model={panel_info.model or 'MISSING'}\")\n        print(f\"panel firmware={panel_info.firmware or 'MISSING'}\")\n        print(f\"panel serial={panel_info.serial or 'MISSING'}\")\n    \n        inv = client.state.inventory\n        if area_auth_required:\n            print(\"area_attribs=MISSING (auth required)\")\n        if area_api_errors:\n            print(f\"area_attribs_api_errors={sorted(set(area_api_errors))}\")\n        if not inv.configured_areas and area_auth_required:\n            print(\"configured_areas=MISSING (auth required)\")\n        else:\n            print(f\"configured_areas={len(inv.configured_areas)}\")\n            for area_id in sorted(inv.configured_areas):\n                area = client.state.areas.get(area_id)\n                name = getattr(area, \"name\", None) if area is not None else None\n                print(f\"area[{area_id}].name={name or 'MISSING'}\")\n    \n        if zone_auth_required:\n            print(\"zone_attribs=MISSING (auth required)\")\n        if zone_api_errors:\n            print(f\"zone_attribs_api_errors={sorted(set(zone_api_errors))}\")\n        if not inv.configured_zones and zone_auth_required:\n            print(\"configured_zones=MISSING (auth required)\")\n        else:\n            print(f\"configured_zones={len(inv.configured_zones)}\")\n            for zone_id in sorted(inv.configured_zones):\n                zone = client.state.zones.get(zone_id)\n                name = getattr(zone, \"name\", None) if zone is not None else None\n                print(f\"zone[{zone_id}].name={name or 'MISSING'}\")\n    \n        await client.close()\n    \n        if not (panel_info.model and panel_info.firmware and panel_info.serial):\n            pytest.fail(\"Panel version info missing (model/firmware/serial).\")\n    \n        if inv.configured_zone_blocks_remaining not in (None, 0):\n            pytest.fail(f\"Zone configured blocks remaining: {inv.configured_zone_blocks_remaining}\")\n        if inv.configured_area_blocks_remaining not in (None, 0):\n            pytest.fail(f\"Area configured blocks remaining: {inv.configured_area_blocks_remaining}\")\n    \n        if area_auth_required or zone_auth_required:\n            pytest.skip(\"Configured inventory requires authorization.\")\n    \n        missing_zone_names = [\n            zone_id\n            for zone_id in sorted(inv.configured_zones)\n>           if not getattr(elk.state.zones.get(zone_id), \"name\", None)\n                           ^^^\n        ]\nE       NameError: name 'elk' is not defined\n\ntest/test_e27_configured_names_live.py:217: NameError"}}
