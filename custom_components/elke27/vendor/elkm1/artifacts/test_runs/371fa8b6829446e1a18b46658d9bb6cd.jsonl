{"run_id": "371fa8b6829446e1a18b46658d9bb6cd", "test_id": "test/test_live_e27_keepalive.py::test_live_system_r_u_alive", "record_type": "test_start", "t_ms": 0, "ts_utc": "2026-01-11T08:24:12Z", "meta": {"pid": 57074}}
{"run_id": "371fa8b6829446e1a18b46658d9bb6cd", "test_id": "test/test_live_e27_keepalive.py::test_live_system_r_u_alive", "record_type": "test_end", "t_ms": 10159, "ts_utc": "2026-01-11T08:24:23Z", "outcome": "fail", "error": {"when": "call", "longrepr": "fut = <coroutine object Event.wait at 0x10952ce40>, timeout = 10.0\n\n    async def wait_for(fut, timeout):\n        \"\"\"Wait for the single Future or coroutine to complete, with timeout.\n    \n        Coroutine will be wrapped in Task.\n    \n        Returns result of the Future or coroutine.  When a timeout occurs,\n        it cancels the task and raises TimeoutError.  To avoid the task\n        cancellation, wrap it in shield().\n    \n        If the wait is cancelled, the task is also cancelled.\n    \n        If the task suppresses the cancellation and returns a value instead,\n        that value is returned.\n    \n        This function is a coroutine.\n        \"\"\"\n        # The special case for timeout <= 0 is for the following case:\n        #\n        # async def test_waitfor():\n        #     func_started = False\n        #\n        #     async def func():\n        #         nonlocal func_started\n        #         func_started = True\n        #\n        #     try:\n        #         await asyncio.wait_for(func(), 0)\n        #     except asyncio.TimeoutError:\n        #         assert not func_started\n        #     else:\n        #         assert False\n        #\n        # asyncio.run(test_waitfor())\n    \n    \n        if timeout is not None and timeout <= 0:\n            fut = ensure_future(fut)\n    \n            if fut.done():\n                return fut.result()\n    \n            await _cancel_and_wait(fut)\n            try:\n                return fut.result()\n            except exceptions.CancelledError as exc:\n                raise TimeoutError from exc\n    \n        async with timeouts.timeout(timeout):\n>           return await fut\n                   ^^^^^^^^^\n\n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/tasks.py:520: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <asyncio.locks.Event object at 0x10953ce30 [unset]>\n\n    async def wait(self):\n        \"\"\"Block until the internal flag is true.\n    \n        If the internal flag is true on entry, return True\n        immediately.  Otherwise, block until another coroutine calls\n        set() to set the flag to true, then return True.\n        \"\"\"\n        if self._value:\n            return True\n    \n        fut = self._get_loop().create_future()\n        self._waiters.append(fut)\n        try:\n>           await fut\nE           asyncio.exceptions.CancelledError\n\n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/locks.py:212: CancelledError\n\nThe above exception was the direct cause of the following exception:\n\nlive_e27_client = <elke27_lib.client.Elke27Client object at 0x107d353d0>\n\n    @pytest.mark.live_e27\n    @pytest.mark.asyncio\n    async def test_live_system_r_u_alive(live_e27_client: Elke27Client) -> None:\n        kernel = live_e27_client._kernel\n        kernel._keepalive_interval_s = 1.0\n        kernel._keepalive_timeout_s = 2.0\n        kernel._keepalive_max_missed = 2\n        kernel._keepalive_enabled = True\n        kernel._start_keepalive()\n    \n        fired = asyncio.Event()\n        result_box: dict[str, bool] = {}\n        original = kernel._send_keepalive_request\n    \n        async def _wrapped_keepalive() -> bool:\n            ok = await original()\n            result_box[\"ok\"] = ok\n            fired.set()\n            return ok\n    \n        kernel._send_keepalive_request = _wrapped_keepalive  # type: ignore[assignment]\n    \n>       await asyncio.wait_for(fired.wait(), timeout=10.0)\n\ntest/test_live_e27_keepalive.py:32: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/tasks.py:519: in wait_for\n    async with timeouts.timeout(timeout):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Timeout [expired]>\nexc_type = <class 'asyncio.exceptions.CancelledError'>\nexc_val = CancelledError(), exc_tb = <traceback object at 0x108f60ac0>\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> Optional[bool]:\n        assert self._state in (_State.ENTERED, _State.EXPIRING)\n    \n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n            self._timeout_handler = None\n    \n        if self._state is _State.EXPIRING:\n            self._state = _State.EXPIRED\n    \n            if self._task.uncancel() <= self._cancelling and exc_type is exceptions.CancelledError:\n                # Since there are no new cancel requests, we're\n                # handling this.\n>               raise TimeoutError from exc_val\nE               TimeoutError\n\n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/timeouts.py:115: TimeoutError"}}
