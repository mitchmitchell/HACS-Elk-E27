{"run_id": "8040b08f1cf748f280617b7284a4d024", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_start", "t_ms": 0, "ts_utc": "2026-01-04T04:10:32Z", "meta": {"pid": 44264}}
{"run_id": "8040b08f1cf748f280617b7284a4d024", "test_id": "test/test_e27_configured_names_live.py::test_live_configured_names", "record_type": "test_end", "t_ms": 59588, "ts_utc": "2026-01-04T04:11:31Z", "outcome": "fail", "error": {"when": "call", "longrepr": "@pytest.mark.integration\n    @pytest.mark.asyncio\n    async def test_live_configured_names() -> None:\n        log_level = str(_env(\"LOG_LEVEL\", \"INFO\") or \"INFO\").upper()\n        logging.basicConfig(level=getattr(logging, log_level, logging.INFO), force=True)\n        logging.getLogger(\"elke27_lib.session\").setLevel(logging.DEBUG)\n    \n        host = _require_env(\"ELKE27_HOST\")\n        port = int(_env(\"ELKE27_PORT\", \"2101\") or 2101)\n        access_code = _require_env(\"ELKE27_ACCESS_CODE\")\n        passphrase = _require_env(\"ELKE27_PASSPHRASE\")\n        mn = _require_env(\"ELKE27_MN\")\n        sn = _require_env(\"ELKE27_SN\")\n        fwver = _require_env(\"ELKE27_FWVER\")\n        hwver = _require_env(\"ELKE27_HWVER\")\n        osver = _require_env(\"ELKE27_OSVER\")\n        timeout_s = float(_env(\"ELKE27_TIMEOUT_S\", \"60.0\") or 60.0)\n        max_runtime_s = float(_env(\"ELKE27_TEST_TIMEOUT_S\", str(timeout_s)) or timeout_s)\n        if max_runtime_s > 60.0:\n            max_runtime_s = 60.0\n        if max_runtime_s <= 0:\n            max_runtime_s = timeout_s\n    \n        client_identity = linking.E27Identity(mn=mn, sn=sn, fwver=fwver, hwver=hwver, osver=osver)\n        client = Elke27Client(\n            features=[\"elke27_lib.features.control\", \"elke27_lib.features.area\", \"elke27_lib.features.zone\"]\n        )\n    \n        panel = {\"host\": host, \"port\": port}\n        creds = _Credentials(access_code=access_code, passphrase=passphrase)\n        link_result = await client.link(panel, client_identity, creds, timeout_s=timeout_s)\n        if not link_result.ok:\n            pytest.fail(f\"Link failed: {link_result.error}\")\n        link_keys = link_result.data\n        session_cfg = SessionConfig(host=host, port=port, hello_timeout_s=timeout_s)\n        connect_result = await client.connect(link_keys, client_identity=client_identity, session_config=session_cfg)\n        if not connect_result.ok:\n            pytest.fail(f\"Connect failed: {connect_result.error}\")\n    \n        pin_value = _env(\"ELKE27_PIN\")\n        if pin_value:\n            pin = int(pin_value)\n            auth_msg = {\"seq\": 110, \"authenticate\": {\"pin\": pin}}\n            client._kernel.session.send_json(auth_msg)\n            print(\"Authenticate sent\")\n    \n        def _send_requests() -> None:\n            client.request((\"control\", \"get_version_info\"))\n            client.request((\"area\", \"get_configured\"))\n            client.request((\"zone\", \"get_configured\"))\n    \n        _send_requests()\n    \n        area_auth_required = False\n        zone_auth_required = False\n        area_names_seen = False\n        zone_names_seen = False\n        area_api_errors: list[int] = []\n        zone_api_errors: list[int] = []\n    \n        start = time.monotonic()\n        next_debug = start + 5.0\n        total_deadline = time.monotonic() + max_runtime_s\n        next_version_retry = time.monotonic() + 5.0\n        while time.monotonic() < total_deadline:\n            try:\n>               await asyncio.to_thread(client._kernel.session.pump_once, timeout_s=0.5)\n\ntest/test_e27_configured_names_live.py:110: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/threads.py:25: in to_thread\n    return await loop.run_in_executor(None, func_call)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:86: in run\n    result = ctx.run(self.task)\n             ^^^^^^^^^^^^^^^^^^\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/concurrent/futures/thread.py:73: in run\n    return fn(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^\nelke27_lib/session.py:435: in pump_once\n    obj = self.recv_json(timeout_s=timeout_s)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nelke27_lib/session.py:369: in recv_json\n    self._require_ready()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <elke27_lib.session.Session object at 0x1080d0b00>\n\n    def _require_ready(self) -> None:\n        if (\n            self.state is not SessionState.ACTIVE\n            or self.sock is None\n            or self.info is None\n            or self._deframe_state is None\n        ):\n>           raise SessionNotReadyError(\n                \"Session is not ACTIVE/ready (call connect() successfully first).\"\n            )\nE           elke27_lib.session.SessionNotReadyError: Session is not ACTIVE/ready (call connect() successfully first).\n\nelke27_lib/session.py:243: SessionNotReadyError"}}
