{"run_id": "f5d5a0967d074345a25f8624610069a3", "test_id": "test/test_discovery.py::test_async_scanner_specific_address", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T22:40:43Z", "meta": {"pid": 94008}}
{"run_id": "f5d5a0967d074345a25f8624610069a3", "test_id": "test/test_discovery.py::test_async_scanner_specific_address", "record_type": "test_end", "t_ms": 2042, "ts_utc": "2025-12-29T22:40:45Z", "outcome": "fail", "error": {"when": "call", "longrepr": "async def _wait_for_connection():\n>       transport, protocol = await future\n                              ^^^^^^^^^^^^\nE       asyncio.exceptions.CancelledError\n\ntest/test_discovery.py:17: CancelledError\n\nThe above exception was the direct cause of the following exception:\n\nmock_discovery_aio_protocol = <function mock_discovery_aio_protocol.<locals>._wait_for_connection at 0x1050f62a0>\n\n    @pytest.mark.asyncio\n    async def test_async_scanner_specific_address(mock_discovery_aio_protocol):\n        \"\"\"Test scanner with a specific address.\"\"\"\n        scanner = AIOELKDiscovery()\n    \n        task = asyncio.ensure_future(\n            scanner.async_scan(timeout=10, address=\"192.168.209.56\")\n        )\n        try:\n>           _, protocol = await asyncio.wait_for(mock_discovery_aio_protocol(), timeout=2.0)\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_discovery.py:43: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/tasks.py:487: in wait_for\n    async with timeouts.timeout(timeout):\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Timeout [expired]>\nexc_type = <class 'asyncio.exceptions.CancelledError'>\nexc_val = CancelledError(), exc_tb = <traceback object at 0x1050f8bc0>\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> bool | None:\n        assert self._state in (_State.ENTERED, _State.EXPIRING)\n    \n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n            self._timeout_handler = None\n    \n        if self._state is _State.EXPIRING:\n            self._state = _State.EXPIRED\n    \n            if self._task.uncancel() <= self._cancelling and exc_type is not None:\n                # Since there are no new cancel requests, we're\n                # handling this.\n                if issubclass(exc_type, exceptions.CancelledError):\n>                   raise TimeoutError from exc_val\nE                   TimeoutError\n\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/timeouts.py:114: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nmock_discovery_aio_protocol = <function mock_discovery_aio_protocol.<locals>._wait_for_connection at 0x1050f62a0>\n\n    @pytest.mark.asyncio\n    async def test_async_scanner_specific_address(mock_discovery_aio_protocol):\n        \"\"\"Test scanner with a specific address.\"\"\"\n        scanner = AIOELKDiscovery()\n    \n        task = asyncio.ensure_future(\n            scanner.async_scan(timeout=10, address=\"192.168.209.56\")\n        )\n        try:\n            _, protocol = await asyncio.wait_for(mock_discovery_aio_protocol(), timeout=2.0)\n        except asyncio.TimeoutError:\n            if task.done():\n                exc = task.exception()\n>               pytest.fail(f\"async_scan completed early with exception: {exc!r}\")\nE               Failed: async_scan completed early with exception: PermissionError(1, 'Operation not permitted')\n\ntest/test_discovery.py:47: Failed"}}
{"run_id": "f5d5a0967d074345a25f8624610069a3", "test_id": "test/test_discovery.py::test_async_scanner_broadcast", "record_type": "test_start", "t_ms": 0, "ts_utc": "2025-12-29T22:40:45Z", "meta": {"pid": 94008}}
{"run_id": "f5d5a0967d074345a25f8624610069a3", "test_id": "test/test_discovery.py::test_async_scanner_broadcast", "record_type": "test_end", "t_ms": 2031, "ts_utc": "2025-12-29T22:40:47Z", "outcome": "fail", "error": {"when": "call", "longrepr": "async def _wait_for_connection():\n>       transport, protocol = await future\n                              ^^^^^^^^^^^^\nE       asyncio.exceptions.CancelledError\n\ntest/test_discovery.py:17: CancelledError\n\nThe above exception was the direct cause of the following exception:\n\nmock_discovery_aio_protocol = <function mock_discovery_aio_protocol.<locals>._wait_for_connection at 0x1050f7060>\n\n    @pytest.mark.asyncio\n    async def test_async_scanner_broadcast(mock_discovery_aio_protocol):\n        \"\"\"Test scanner with a broadcast.\"\"\"\n        scanner = AIOELKDiscovery()\n    \n        task = asyncio.ensure_future(scanner.async_scan(timeout=0.01))\n        try:\n>           _, protocol = await asyncio.wait_for(mock_discovery_aio_protocol(), timeout=2.0)\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ntest/test_discovery.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/tasks.py:487: in wait_for\n    async with timeouts.timeout(timeout):\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Timeout [expired]>\nexc_type = <class 'asyncio.exceptions.CancelledError'>\nexc_val = CancelledError(), exc_tb = <traceback object at 0x1051b1100>\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -> bool | None:\n        assert self._state in (_State.ENTERED, _State.EXPIRING)\n    \n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n            self._timeout_handler = None\n    \n        if self._state is _State.EXPIRING:\n            self._state = _State.EXPIRED\n    \n            if self._task.uncancel() <= self._cancelling and exc_type is not None:\n                # Since there are no new cancel requests, we're\n                # handling this.\n                if issubclass(exc_type, exceptions.CancelledError):\n>                   raise TimeoutError from exc_val\nE                   TimeoutError\n\n/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/timeouts.py:114: TimeoutError\n\nDuring handling of the above exception, another exception occurred:\n\nmock_discovery_aio_protocol = <function mock_discovery_aio_protocol.<locals>._wait_for_connection at 0x1050f7060>\n\n    @pytest.mark.asyncio\n    async def test_async_scanner_broadcast(mock_discovery_aio_protocol):\n        \"\"\"Test scanner with a broadcast.\"\"\"\n        scanner = AIOELKDiscovery()\n    \n        task = asyncio.ensure_future(scanner.async_scan(timeout=0.01))\n        try:\n            _, protocol = await asyncio.wait_for(mock_discovery_aio_protocol(), timeout=2.0)\n        except asyncio.TimeoutError:\n            if task.done():\n                exc = task.exception()\n>               pytest.fail(f\"async_scan completed early with exception: {exc!r}\")\nE               Failed: async_scan completed early with exception: PermissionError(1, 'Operation not permitted')\n\ntest/test_discovery.py:72: Failed"}}
