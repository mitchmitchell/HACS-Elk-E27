{"run_id": "d96a27d93fbe43d0bf1283304d37a03f", "test_id": "test/test_live_e27_bypass_events.py::test_live_zone_bypass_event_cycle", "record_type": "test_start", "t_ms": 0, "ts_utc": "2026-01-14T08:26:39Z", "meta": {"pid": 62351}}
{"run_id": "d96a27d93fbe43d0bf1283304d37a03f", "test_id": "test/test_live_e27_bypass_events.py::test_live_zone_bypass_event_cycle", "record_type": "test_end", "t_ms": 37708, "ts_utc": "2026-01-14T08:27:17Z", "outcome": "fail", "error": {"when": "call", "longrepr": "fut = <coroutine object Event.wait at 0x1067e7060>, timeout = 30.0\n\n    async def wait_for(fut, timeout):\n        \"\"\"Wait for the single Future or coroutine to complete, with timeout.\n    \n        Coroutine will be wrapped in Task.\n    \n        Returns result of the Future or coroutine.  When a timeout occurs,\n        it cancels the task and raises TimeoutError.  To avoid the task\n        cancellation, wrap it in shield().\n    \n        If the wait is cancelled, the task is also cancelled.\n    \n        If the task suppresses the cancellation and returns a value instead,\n        that value is returned.\n    \n        This function is a coroutine.\n        \"\"\"\n        # The special case for timeout <= 0 is for the following case:\n        #\n        # async def test_waitfor():\n        #     func_started = False\n        #\n        #     async def func():\n        #         nonlocal func_started\n        #         func_started = True\n        #\n        #     try:\n        #         await asyncio.wait_for(func(), 0)\n        #     except asyncio.TimeoutError:\n        #         assert not func_started\n        #     else:\n        #         assert False\n        #\n        # asyncio.run(test_waitfor())\n    \n    \n        if timeout is not None and timeout <= 0:\n            fut = ensure_future(fut)\n    \n            if fut.done():\n                return fut.result()\n    \n            await _cancel_and_wait(fut)\n            try:\n                return fut.result()\n            except exceptions.CancelledError as exc:\n                raise TimeoutError from exc\n    \n        async with timeouts.timeout(timeout):\n>           return await fut\n                   ^^^^^^^^^\n\n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/tasks.py:520: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <asyncio.locks.Event object at 0x1067f1790 [unset]>\n\n    async def wait(self):\n        \"\"\"Block until the internal flag is true.\n    \n        If the internal flag is true on entry, return True\n        immediately.  Otherwise, block until another coroutine calls\n        set() to set the flag to true, then return True.\n        \"\"\"\n        if self._value:\n            return True\n    \n        fut = self._get_loop().create_future()\n        self._waiters.append(fut)\n        try:\n>           await fut\nE           asyncio.exceptions.CancelledError\n\n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/locks.py:212: CancelledError\n\nThe above exception was the direct cause of the following exception:\n\nlive_e27_client = <elke27_lib.client.Elke27Client object at 0x1065894f0>\n\n    @pytest.mark.live_e27\n    @pytest.mark.asyncio\n    async def test_live_zone_bypass_event_cycle(live_e27_client: Elke27Client) -> None:\n        \"\"\"\n        Wait for any zone to be bypassed, then unbypassed, within 30 seconds.\n        \"\"\"\n        loop = asyncio.get_running_loop()\n        bypass_event = asyncio.Event()\n        unbypass_event = asyncio.Event()\n        bypassed_zone_id: int | None = None\n    \n        def _on_evt(evt) -> None:\n            nonlocal bypassed_zone_id\n            if not isinstance(evt, ZoneStatusUpdated):\n                return\n            if \"bypassed\" not in evt.changed_fields:\n                return\n            zone = live_e27_client._kernel.state.zones.get(evt.zone_id)\n            if zone is None or not isinstance(zone.bypassed, bool):\n                return\n            if zone.bypassed:\n                if bypassed_zone_id is None:\n                    bypassed_zone_id = evt.zone_id\n                    loop.call_soon_threadsafe(bypass_event.set)\n            elif bypassed_zone_id == evt.zone_id:\n                loop.call_soon_threadsafe(unbypass_event.set)\n    \n        unsubscribe = live_e27_client.subscribe_typed(_on_evt)\n        try:\n            deadline = loop.time() + _LIVE_TIMEOUT_S\n>           await asyncio.wait_for(bypass_event.wait(), timeout=_LIVE_TIMEOUT_S)\n\ntest/test_live_e27_bypass_events.py:52: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/tasks.py:519: in wait_for\n    async with timeouts.timeout(timeout):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <Timeout [expired]>\nexc_type = <class 'asyncio.exceptions.CancelledError'>\nexc_val = CancelledError(), exc_tb = <traceback object at 0x10680c040>\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> Optional[bool]:\n        assert self._state in (_State.ENTERED, _State.EXPIRING)\n    \n        if self._timeout_handler is not None:\n            self._timeout_handler.cancel()\n            self._timeout_handler = None\n    \n        if self._state is _State.EXPIRING:\n            self._state = _State.EXPIRED\n    \n            if self._task.uncancel() <= self._cancelling and exc_type is exceptions.CancelledError:\n                # Since there are no new cancel requests, we're\n                # handling this.\n>               raise TimeoutError from exc_val\nE               TimeoutError\n\n/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib/python3.12/asyncio/timeouts.py:115: TimeoutError"}}
